{
  "section_info": {
    "section_number": "4.2",
    "title": "Error Handling",
    "description": "How to anticipate and manage errors in Python programs.",
    "learning_outcomes": [
      "Use try-except blocks to handle exceptions.",
      "Raise and create custom exceptions."
    ],
    "subsections": [
      {
        "subsection_number": "4.2.1",
        "title": "Basic Exception Handling",
        "description": "Introduction to using try-except blocks."
      },
      {
        "subsection_number": "4.2.2",
        "title": "Raising Exceptions",
        "description": "How and when to raise exceptions."
      }
    ]
  },
  "subsections": [
    {
      "subsection_info": {
        "subsection_number": "4.2.1",
        "title": "Basic Exception Handling",
        "description": "Introduction to using try-except blocks."
      },
      "content": "# Basic Exception Handling\n\nError handling is a fundamental concept in Python programming, allowing developers to preemptively address potential issues that might arise during the execution of their code. Exception handling ensures that the program can deal with unexpected errors gracefully, without crashing. It enables developers to provide clear error messages, safeguard against data corruption, and maintain the robustness of applications. This section delves into the basics of exception handling in Python, covering the essential theories, practical examples, and exercises for beginners to grasp and apply these concepts effectively.\n\n## Concepts and Theory\n\nIn Python, exceptions are events detected during execution that disrupt the regular flow of a program. These can arise from various sources, such as logical errors in code, incorrect input from users, or external factors like file I/O operations failing. Understanding the hierarchy of exception classes is crucial, as it allows programmers to catch and handle errors more precisely.\n\n### Exception Hierarchy\nPython's exceptions stem from a base class called `BaseException`. From this, a hierarchy of error types diverges, addressing different error categories:\n\n- `Exception`: All built-in, non-system-exiting exceptions are derived from this class. It is a catch-all for many categories of errors.\n  - `ArithmeticError`: Base class for arithmetic-related errors like `OverflowError`, `ZeroDivisionError`, etc.\n  - `IOError`: An alias for `OSError` and base class for input/output related errors.\n  - `ImportError`: Raised when an import statement fails.\n  - `IndexError`: Raised when a sequence subscript is out of range.\n\n### The `try` and `except` Block\nThe `try` block lets you test a block of code for errors. The `except` block enables you to handle the error.\n\n### The `else` Clause\nAn `else` block can be used after all `except` blocks. The code inside it is executed if the `try` block doesn't raise an exception.\n\n### The `finally` Block\nThe `finally` block, if specified, will be executed regardless if the `try` block raises an error or not. This is useful for clean-up actions that must be executed under all circumstances.\n\n## Examples and Implementation\n\nHere, we'll look at practical implementations of exception handling in Python.\n\n```python\n# Example 1: Basic try-except block\ntry:\n    print(\"Attempting to divide by zero...\")\n    result = 10 / 0\nexcept ZeroDivisionError:\n    print(\"Caught a ZeroDivisionError!\")\n\n# Example 2: Multiple exceptions\ntry:\n    # This will raise a KeyError\n    dict_value = {\"a\": 1}[\"b\"]\nexcept (KeyError, IndexError) as e:\n    print(f\"Caught an error: {e}\")\n\n# Example 3: Using the else clause\ntry:\n    print(\"No exception raised.\")\nexcept Exception as e:\n    print(f\"Caught an exception: {e}\")\nelse:\n    print(\"This executes because no exception was raised in the try block.\")\n\n# Example 4: Ensuring 'finally' block execution\ntry:\n    print(\"Raise an exception.\")\n    raise ValueError(\"This is a ValueError.\")\nexcept ValueError as e:\n    print(f\"Handled ValueError: {e}\")\nfinally:\n    print(\"This will always execute, regardless of exceptions.\")\n```\n\n## Practice Exercises\n\n1. Write a function that takes two numbers as input from the user, divides one by the other, and handles any `ZeroDivisionError` that might occur, providing a friendly error message instead of crashing the program.\n2. Create a Python script that tries to open a file for reading that does not exist. Catch the `FileNotFoundError` that arises and print a message indicating that the file was not found.\n3. Implement a `try-except-else` block in which the `try` block checks if a given dictionary key exists. Use the `else` block to print a message saying the key exists and displays its value if no exception occurs.\n\n## Key Takeaways\n\n- **Error handling** in Python is performed using the `try`, `except`, `else`, and `finally` blocks. These constructs enhance the robustness of your programs by gracefully handling exceptions.\n- The **exception hierarchy** in Python organizes different types of errors under a system of parent and child classes, enabling targeted exception handling.\n- Practical implementation of exception handling involves anticipating potential errors, catching them specifically or generically, and implementing clean-up actions or fallbacks as needed.\n- Regular practice with **exception handling** can significantly improve your ability to write resilient, error-tolerant Python code."
    },
    {
      "subsection_info": {
        "subsection_number": "4.2.2",
        "title": "Raising Exceptions",
        "description": "How and when to raise exceptions."
      },
      "content": "# Raising Exceptions\n\nIn Python, exceptions are events detected during execution that interrupt the normal flow of a program. Error handling is a fundamental concept in Python programming that allows a more robust and predictable execution of software by managing these exceptions gracefully. Among various error handling techniques, raising exceptions is a vital mechanism allowing programmers to purposely generate custom or built-in exceptions under specific circumstances. This section delves into why and how to raise exceptions, offering insights into both the theoretical framework and practical applications of this technique in Python.\n\n## Concepts and Theory\n\n### What is Exception Raising?\nException raising in Python is the process of manually triggering an exception during runtime. This is done using the `raise` keyword, followed by an instance of the exception to be thrown. This mechanism is often utilized to enforce certain conditions within the code, ensuring that the program only executes in the intended manner.\n\n### Why Raise Exceptions?\n- **Enforcing Constraints**: To ensure that function inputs or program states adhere to specific requirements.\n- **Debugging and Maintenance**: By signaling errors clearly, raising exceptions makes it easier to understand and fix bugs.\n- **Control Flow**: In some cases, exceptions are used to manage the flow of execution in complex applications.\n  \n### Types of Exceptions to Raise\n- **Built-in Exceptions**: Python provides a variety of built-in exceptions such as `ValueError`, `TypeError`, and `IOError` that can be raised to indicate common error conditions.\n- **Custom Exceptions**: Developers can define custom exception classes that inherit from Python's base `Exception` class, allowing for more descriptive error reporting tailored to an application's needs.\n\n## Examples and Implementation\n\n### Raising a Built-in Exception\nRaising a built-in exception typically involves a conditional check followed by the `raise` statement.\n\n```python\ndef divide(x, y):\n    if y == 0:\n        raise ZeroDivisionError(\"Attempt to divide by zero.\")\n    return x / y\n```\nIn this example, a `ZeroDivisionError` exception is raised if the divisor (`y`) is zero.\n\n### Creating and Raising a Custom Exception\nCustom exceptions offer the flexibility to express specific error conditions more clearly.\n\n```python\nclass NegativeInputError(Exception):\n    \"\"\"Exception raised for errors in the input.\"\"\"\n\n    def __init__(self, message=\"Negative value provided\"):\n        self.message = message\n        super().__init__(self.message)\n        \ndef square_root(value):\n    if value < 0:\n        raise NegativeInputError(\"Square root of negative number is not allowed.\")\n    return value ** 0.5\n```\n\nIn this snippet, a custom exception, `NegativeInputError`, is defined and raised if a negative value is passed to the `square_root` function.\n\n## Practice Exercises\n\n1. Write a function `validate_age(age)` that raises a `ValueError` if the age given is less than 18, indicating that the user is underage for certain activities.\n\n2. Create a custom exception `InvalidEmailError`, and use it in a function `validate_email(email)` that checks if the provided email contains an \"@\" symbol and raises the custom exception if it does not.\n\n3. Develop a function `convert_to_int(value)` that tries to convert its argument to an integer. If the conversion fails, raise a `TypeError` with an informative message.\n\n## Key Takeaways\n\n- **Raising exceptions** is a powerful mechanism in Python for signaling errors and enforcing constraints within programs.\n- Exceptions can be **built-in** or **custom**, with custom exceptions providing a way to express specific error conditions clearly.\n- Using the `raise` statement, Python programmers can **manually trigger exceptions**, allowing for fine-grained control over error handling and program flow.\n- Practically implementing exception raising in code aids in **creating more robust, predictable, and maintainable software**."
    }
  ]
}